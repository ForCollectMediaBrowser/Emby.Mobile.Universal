<!--
***********************************************************************************************
Microsoft.NetNative.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true'">
    <_ProjectNToolchainEnabled>true</_ProjectNToolchainEnabled>
  </PropertyGroup>
  
  <!-- Make sure WindowsSDK_LibraryPath is available to us so that MCG can load up the libs correctly -->
  <Import Condition="'$(_ProjectNToolchainEnabled)' == 'true' And '$(WindowsSDK_IncludePath)' == '' And Exists('$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\Windows.props')" 
          Project="$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\Windows.props" />
  <Import Condition="'$(_ProjectNToolchainEnabled)' == 'true' And '$(WindowsSDK_IncludePath)' == '' And Exists('$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\$(TargetPlatformIdentifier)\$(TargetPlatformVersion)\UAP.props')" 
          Project="$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\$(TargetPlatformIdentifier)\$(TargetPlatformVersion)\UAP.props" />

  <!-- Create list of supported platforms based on installed SDKs. 
       VS uses this list to alter UI behavior (project settings). -->
  <PropertyGroup Condition="'$(ProjectNProfileEnabled)' == 'true'">
    <AllowedPlatformsForProjectN Condition="Exists('$(MSBuildThisFileDirectory)\ARM\ilc')">ARM</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN Condition="Exists('$(MSBuildThisFileDirectory)\x64\ilc')">$(AllowedPlatformsForProjectN),x64</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN Condition="Exists('$(MSBuildThisFileDirectory)\x86\ilc')">$(AllowedPlatformsForProjectN),x86</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN>$(AllowedPlatformsForProjectN.TrimStart(','))</AllowedPlatformsForProjectN>
  </PropertyGroup>

  <!-- Provides a default target platform for finding the ilc.exe version when
       the project is configured to AnyCPU -->
  <PropertyGroup>
    <_PlatformTargetForIlcVersion Condition="'$(PlatformTarget)'!='AnyCPU'">$(PlatformTarget)</_PlatformTargetForIlcVersion>
    <_PlatformTargetForIlcVersion Condition="'$(PlatformTarget)'=='AnyCPU'">x86</_PlatformTargetForIlcVersion>
  </PropertyGroup>

  <PropertyGroup>
    <SkipILCompilation>true</SkipILCompilation>
  </PropertyGroup>
  
  <!-- Adds a <build:Item> tag containing the version of ilc.exe in
       the output AppxManifest if the project is using ProjectN -->
  <ItemGroup Condition="'$(_ProjectNToolchainEnabled)'=='true'">
    <AppxManifestMetadata Include="$(MSBuildExtensionsPath)\Microsoft\.NETNative\$(_PlatformTargetForIlcVersion)\ilc\ilc.exe" />
  </ItemGroup>

  <ItemGroup Condition="'$(_ProjectNToolchainEnabled)'=='true'">
    <AppxManifestMetadata Include="OptimizingToolset">
      <Value>ilc.exe</Value>
    </AppxManifestMetadata>
  </ItemGroup>

  <!-- 
       Insert the SDK references for VCLibs and Microsoft.Net.Native.Runtime FW packages only if we have .NET Native enabled and the app contains managed code.
       "App contains managed code" is determined by checking the presence of System.Runtime.dll in the _IlcInputPath location since this assembly is deployed only when
       managed code exists in the app.
       
       Store relies on a similar logic as well.
       
       This ensures that we do not accidently insert the reference to Microsoft.Net.Native.Runtime package in purely native projects (e.g. C++ or JS).
   -->
       
  <Target Name="AddSDKReferences" Condition="'$(_ProjectNToolchainEnabled)'=='true' and Exists('$(_IlcInputPath)System.Runtime.dll')" AfterTargets="PrepareILCInputFolder">
    <GetInstalledSDKLocations
           SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)"
           SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)"
           SDKRegistryRoot="$(SDKReferenceRegistryRoot)"
           TargetPlatformVersion="$(TargetPlatformVersion)"
           TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
           Condition="'@(InstalledSDKLocations)' == ''"
           >
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations"/>
    </GetInstalledSDKLocations>
    
    <ItemGroup>
      <!-- This naively hopes installed packages are compatible with us, but we will
           later insert a package dependency that has the actual required version. -->
      <NETNativeSDKs Include="Microsoft.NET.Native.Runtime.1.1, Version=1.1" />
      <NETNativeSDKs Include="Microsoft.VCLibs, Version=14.0" />
    </ItemGroup>

    <ResolveSDKReference
      SDKReferences="@(NETNativeSDKs)"
      TargetPlatformVersion="$(TargetPlatformVersion)"
      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
      TargetedSDKConfiguration="$(TargetedSDKConfiguration)"
      TargetedSDKArchitecture="$(TargetedSDKArchitecture)"
      ProjectName="$(ProjectName)"
      InstalledSDKs ="@(InstalledSDKLocations)"
    >
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedNETNativeSDKs"/>
    </ResolveSDKReference>

    <GetFrameworkSdkPackages FrameworkSdkReferences="@(ResolvedNETNativeSDKs)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="NETNativeFrameworkPackages" />
    </GetFrameworkSdkPackages>

    <ItemGroup>
      <FrameworkSdkPackage Include="@(NETNativeFrameworkPackages)" />
    </ItemGroup>
  </Target>

  <Target Name="ComputeExtensionSDKReferencePaths">
    <ItemGroup>
      <!-- Don't include platform.winmd otherwise it will be added to Ilc's /externalReferencePath argument and loaded
           which will cause all sorts of problems because it is not a valid winmd file and it is not valid .NET 
           metadata. For example types don't derived from System.Object. 
      -->
      <ExtensionSDKReferencePath Include="@(ReferencePath->DirectoryName())"
                                 Condition="'%(ReferencePath.CopyLocal)' != 'true' and '%(ReferencePath.ResolvedFrom)' == 'GetSDKReferenceFiles' and '%(ReferencePath.Filename)%(ReferencePath.Extension)' != 'platform.winmd'"
                                 KeepDuplicates="false"/>
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <_GatekeeperPlatformTarget>$(PlatformTarget)</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">x64</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">x86</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">arm</_GatekeeperPlatformTarget>
  </PropertyGroup>

  <Target Name="RunGatekeeper"
          AfterTargets="AfterGenerateAppxManifest"
          DependsOnTargets="ComputeExtensionSDKReferencePaths;PrepareILCInputFolder"
          Condition="('$(ProjectNProfileEnabled)' == 'true' and '$(EnableGateKeeperAnalysis)' == 'true') And Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">

    <ItemGroup>
      <_GatekeeperLibPath Include="@(ExtensionSDKReferencePath)"/>
      <_GatekeeperLibPath Include="$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\lib\Facades" KeepDuplicates="false"/>
      <_GatekeeperLibPath Include="$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\lib\IL" KeepDuplicates="false"/>
      <_GatekeeperLibPath Include="$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\lib\Private" KeepDuplicates="false"/>
      <_GatekeeperWinMDPath Condition="Exists('$(_IlcInputPath)WinMetadata\Windows.winmd')" Include="$(_IlcInputPath)WinMetadata\Windows.winmd"/>
      <_GatekeeperWinMDPath Condition="'$(_GatekeeperWinMDPath)' == ''" Include="$(TargetPlatformWinMDLocation)\*.winmd" />
      <_GateKeeperWinMDFile Include="@(AppLocalMetadataFile)" />
    </ItemGroup>

    <PropertyGroup>
      <_GatekeeperCmd>"$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\tools\Gatekeeper.exe"</_GatekeeperCmd>
      <_GatekeeperCmd>$(_GatekeeperCmd) /In:"$(_IlcInputPath)</_GatekeeperCmd>
      <!-- We quote the input folder in case there are spaces in the path. 
           However, if the last character is '\', adding a quote after it 
           confuses command line parser. It thinks we are trying to escape 
           the quote and makes it part of the path, which causes Gatekeeper 
           to complain about an invalid character in the path. Let's add 
           one more '\' in this case.
      -->
      <_GatekeeperCmd Condition="$(_GatekeeperCmd.EndsWith('\'))">$(_GatekeeperCmd)\</_GatekeeperCmd>
      <_GatekeeperCmd>$(_GatekeeperCmd)"</_GatekeeperCmd>

      <_GatekeeperCmd>$(_GatekeeperCmd) /Lib:"@(_GatekeeperLibPath,'" /Lib:"')"</_GatekeeperCmd>
      <_GatekeeperCmd Condition="'$(_GatekeeperWinMDPath)' != ''">$(_GatekeeperCmd) /WinMD:"@(_GateKeeperWinMDPath,'" /WinMD:"')"</_GatekeeperCmd>

      <_GatekeeperCmd Condition="'$(ProjectNVSTelemetrySession)' != ''">$(_GatekeeperCmd) /VSTelemetrySessionSettings:$(ProjectNVSTelemetrySession)</_GatekeeperCmd>
      <_GatekeeperCmd>$(_GatekeeperCmd) /RdXmlPath:"$(MSBuildThisFileDirectory)LibraryXML"</_GatekeeperCmd>
    </PropertyGroup>

    <Exec Command="$(_GatekeeperCmd)">
      <Output TaskParameter="ExitCode" PropertyName="_GatekeeperExitCode" />
    </Exec>
  </Target>

  <UsingTask TaskName="ValidateRdXmlTask" AssemblyFile="$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll"
          Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')"/>

  <UsingTask TaskName="LoggerBasedExecTask" AssemblyFile="$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll"
          Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')"/>

  <UsingTask TaskName="IlcErrorTask" AssemblyFile="$(MSBuildThisFileDirectory)$(_PlatformTargetForIlcVersion)\ilc\ilc.exe" />
  
  <Target Name="ValidateRdXml"
          AfterTargets="AfterGenerateAppxManifest"
          BeforeTargets="BuildNativePackage"
          Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')">

    <ItemGroup>
      <!-- Include runtime directives -->
      <RdXmlFiles Include="*.rd.xml"/>
    </ItemGroup>

    <ValidateRdXmlTask Files="@(RdXmlFiles)"/>
  </Target>


  <Target Name="CheckForAnyCPU">
    <IlcErrorTask Condition="'$(PlatformTarget)' == 'AnyCPU'" ResourceName="Error_AnyCPU" />
  </Target>

  <UsingTask TaskName="ComputeManagedBinaries" AssemblyFile="$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\ilc.exe"
          Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')"/>
  
  <Target Name="ComputeIlcParameters"
          DependsOnTargets="ComputeExtensionSDKReferencePaths">
    
    <!-- Compute the target location for ILC outputs -->
    <PropertyGroup Condition="'$(IlcOutputPath)'==''">
      <IlcOutputPath>$(OutputPath)ilc\</IlcOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcOutputPath)" >
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcOutputPath" />
    </ConvertToAbsolutePath>

    <PropertyGroup Condition="'$(IlcIntermediateRootPath)'==''">
      <IlcIntermediateRootPath>$(IntermediateOutputPath)ilc\</IlcIntermediateRootPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcIntermediateRootPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcIntermediateRootPath" />
    </ConvertToAbsolutePath>

    <GetSdkPropertyValue     TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                             SDKIdentifier="$(SDKIdentifier)"
                             SDKVersion="$(SDKVersion)"
                             TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                             TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                             TargetPlatformVersion="$(TargetPlatformVersion)"
                             PropertyName="WindowsSdkDir">
            <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>

    <PropertyGroup>
      <WindowsSdkPath Condition="'$(WindowsSdkPath)' == ''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</WindowsSdkPath>
      <WindowsSdkPath Condition="'$(WindowsSdkPath)' == ''">$(_TargetPlatformSdkDir)</WindowsSdkPath>
    </PropertyGroup>

    <!-- Prepare ilc arguments. -->
    <PropertyGroup>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(WindowsSDK_LibraryPath)'!=''">$(WindowsSDK_LibraryPath)</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='ARM' And '$(WindowsSDK_LibraryPath_arm)'!=''">$(WindowsSDK_LibraryPath_arm)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='x86' And '$(WindowsSDK_LibraryPath_x86)'!=''">$(WindowsSDK_LibraryPath_x86)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='x64' And '$(WindowsSDK_LibraryPath_x64)'!=''">$(WindowsSDK_LibraryPath_x64)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(_TargetPlatformSdkDir)')">$(_TargetPlatformSdkDir.TrimEnd('\'))</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(TargetPlatformSdkPath)\Lib\winv6.4\um')">$(TargetPlatformSdkPath)\Lib\winv6.4\um</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(TargetPlatformSdkPath)\lib\$(PlatformTarget)')">$(TargetPlatformSdkPath)\lib\$(PlatformTarget)</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'==''">$(TargetPlatformSdkPath)\Lib\winv6.3\um</IlcTargetPlatformSdkLibPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcTargetPlatformSdkLibPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcTargetPlatformSdkLibPath" />
    </ConvertToAbsolutePath>

    <PropertyGroup>
      <_IlcExitCode />
      <_IlcExePath>$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\ilc.exe</_IlcExePath>
      <_IlcInputPath>$(_IlcIntermediateRootPath)in\</_IlcInputPath>
      <_IlcIntermediatePath>$(_IlcIntermediateRootPath)intermediate\</_IlcIntermediatePath>
      <_IlcVerbosity>normal</_IlcVerbosity>
      <_IlcKeepIntermediates>true</_IlcKeepIntermediates>
      <_IlcSuppressPDBWarnings>true</_IlcSuppressPDBWarnings>
      <_IlcBuildType Condition="'$(Optimize)'=='true'">ret</_IlcBuildType>
      <_IlcBuildType Condition="'$(Optimize)'!='true'">chk</_IlcBuildType>
      <_IlcExternalReferencePath>/externalReferencePath:"@(ExtensionSDKReferencePath,'" /externalReferencePath:"')"</_IlcExternalReferencePath>
    </PropertyGroup>
  </Target>

  <!-- The ILC input folder is created when .Net Native compilation is enabled, and when it isn't but we're running Gatekeeper.
       This ensures Gatekeeper is run on the same set of inputs as if .Net Native were enabled -->
  <Target Name="PrepareILCInputFolder"
          BeforeTargets="RunGatekeeper"
          AfterTargets="ValidateRdXml"
          DependsOnTargets="ComputeIlcParameters"
          Condition="'$(ProjectNProfileEnabled)' == 'true' and ('$(_ProjectNToolchainEnabled)' == 'true' or '$(EnableGateKeeperAnalysis)' == 'true')"
          >
    <!-- Deploy managed appx package layout to _IlcInputPath -->
    <ItemGroup>
      <_IlcInputPayload Include="@(AppxPackagePayload->'$(_IlcInputPath)%(TargetPath)')" />
    </ItemGroup>

    <!-- 
         Sanitizing ILC input folder:
         When .net native is disabled (i.e. the default debug configuration), gatekeeper will populate this folder with CoreCLR related libraries.
         If user switches the configuration and enables .net native, the very same folder will be used as input to ILC.
         Then when user builds without doing a clean first, 
            - if there happens to be a file in AppxPackagePayload that already exists in this directory it'll be overwritten. However,
            - those files in this directory that doesn't exist in the AppxPackagePayload, such as CoreCLR specific files, will just stay. 
         The later will cause a failure in ILC later on.
         To prevent that we're removing any file from this directory that doesn't exist in AppxPackagePayload
    -->
    <ItemGroup>
      <_ResidualFilesInIlcInputPath Include="$(_IlcInputPath)**\*" />
      <_ResidualFilesInIlcInputPath Remove="@(_IlcInputPayload)" />
    </ItemGroup>
    <Delete Files="@(_ResidualFilesInIlcInputPath)" />


    <!-- Find app-local Windows.winmd if it exists -->
    <ItemGroup>
      <AppLocalMetadataFile Include="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'WinMetadata\Windows.winmd'" />
    </ItemGroup>
    <PropertyGroup>
      <AppLocalMetadataPath>%(AppLocalMetadataFile.RootDir)%(AppLocalMetadataFile.Directory)</AppLocalMetadataPath>
    </PropertyGroup>

      <Copy SourceFiles="@(AppxPackagePayload)"
          DestinationFiles="@(_IlcInputPayload)"
          SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
          >
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>

    <Copy SourceFiles="@(FinalAppxManifest)"
          DestinationFolder="$(_IlcInputPath)"
          Condition="Exists('%(FullPath)')" />

    <!-- If an app-local Windows.winmd was found, we want to defer to it for platform metadata -->
    <PropertyGroup Condition="Exists('$(_IlcInputPath)WinMetadata\Windows.winmd')">
      <_TargetPlatformMetadataPath>$(_IlcInputPath)WinMetadata</_TargetPlatformMetadataPath>  
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('@(UnionWinmdPath)')">
      <_TargetPlatformMetadataPath>$([System.IO.Path]::GetDirectoryName('%(UnionWinmdPath.FullPath)'))</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('$(TargetPlatformWinMDLocation)')">
      <_TargetPlatformMetadataPath>$(TargetPlatformWinMDLocation)</_TargetPlatformMetadataPath>
    </PropertyGroup>

    <Error Condition="'$(_TargetPlatformMetadataPath)' == ''" Text="Could not find an existing platform WinMD location" />
    
  </Target>

  <Target Name="ComputeNativePackageInputsAndOutputs"
    Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')"
    >
    <!-- 
      Inputs and outputs to ILC:

        Inputs:
          - Managed binaries (*.exe / *.dll / *.winmd)
          - Metadata directives (*.rd.xml)
          - Xaml roots logs (*.xr.xml)
          - Appxmanifest.xml

        Outputs:
          - Compiled native binaries
            - For managed apps: exename.exe, exename.dll
            - For hybrid apps: <PackageIdGuid>.exe, <PackageIdGuid>.dll
    -->
    <ComputeManagedBinaries InputFiles="@(AppxPackagePayload)" AppxManifest="$(FinalAppxManifestName)" OutputPath="$(_IlcOutputPath)">
      <Output TaskParameter="ManagedFiles" ItemName="ManagedAppxPackagePayload" />
      <Output TaskParameter="OutputDotNetNativeFiles" ItemName="BuildNativePackageOutputs" />
    </ComputeManagedBinaries>

    <ItemGroup>
      <!-- Runtime reflection directives affect types / metadata retained in compilation -->
      <BuildNativePackagesInputs Include="*.rd.xml" />

      <!-- Xaml roots are entrypoints into managed code and affect types / methods retained in compilation -->
      <BuildNativePackagesInputs Include="*.xr.xml" />
      
      <!-- ILC modifies the appx manifest -->
      <BuildNativePackagesInputs Include="$(FinalAppxManifestName)" />

      <!-- Include winmds and managed binaries -->
      <BuildNativePackagesInputs Include="@(ManagedAppxPackagePayload)" />
    </ItemGroup>
  </Target>

  <!-- 
    This target detects whether compilation of IL is required as part of BuildNativePackage.
    If all managed input assemblies are up to date with respect to output native binaries,
    this target will be skipped since it's up to date.  That allows ILC to run in a
    pass-through mode that copies all the non-code artifacts through to the output folder.
  -->
  <Target Name="BuildNativePackageCompilationRequired"
          AfterTargets="ValidateRdXml;RunGatekeeper"
          Condition="'$(_ProjectNToolchainEnabled)' == 'true'"
          DependsOnTargets="CheckForAnyCPU;ComputeNativePackageInputsAndOutputs"
          Inputs="@(BuildNativePackagesInputs)"
          Outputs="@(BuildNativePackageOutputs)">

    <CreateProperty Value="false">
      <Output PropertyName="SkipILCompilation" TaskParameter="ValueSetByTask"/>
    </CreateProperty>
    
  </Target>

  <!-- Build native appx package. Runs after managed appx package payload is computed. -->
  <Target Name="BuildNativePackage"
          AfterTargets="ValidateRdXml;RunGatekeeper;BuildNativePackageCompilationRequired"
          Condition="'$(_ProjectNToolchainEnabled)' == 'true'"
          DependsOnTargets="CheckForAnyCPU;ComputeIlcParameters;"
          >

    
    <PropertyGroup>
      <!-- Name of manifest file is predefined -->
      <_AppxManifestXmlFileName>AppxManifest.xml</_AppxManifestXmlFileName>
      <!-- Expected location of result manifest file where it supposed to be dropped by ILC -->
      <_TransformedAppxManifestXmlFile>$(_IlcOutputPath)$(_AppxManifestXmlFileName)</_TransformedAppxManifestXmlFile>

      <!-- ILC hardcodes resources.pri as the file name so we do the same here -->
      <_ProjectPriFileName>resources.pri</_ProjectPriFileName>
      <_TransformedProjectPriFullPath>$(_IlcOutputPath)$(_ProjectPriFileName)</_TransformedProjectPriFullPath>
    </PropertyGroup>

    <!-- Delete existing transformed file -->
    <Delete Condition="'$(SkipILCompilation)' != 'true'" Files="$(_TransformedAppxManifestXmlFile)"/>

    <!-- Invoke ilc. -->
    <PropertyGroup>
      <FrameworkPathOverride Condition="$(FrameworkPathOverride) == ''">$(MSBuildExtensionsPath32)\..\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5.1</FrameworkPathOverride>

      <_IlcCmd                                                                                    >/in:"$(_IlcInputPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /out:"$(_IlcOutputPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /intermediatespath:"$(_IlcIntermediatePath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /v:$(_IlcVerbosity)</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /keepintermediates:$(_IlcKeepIntermediates)</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /buildtype:$(_IlcBuildType)</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /exename:"$(TargetFileName)"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /makepripath:"$(MakePriExeFullPath)"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /appPriProjectRoot:"$(ProjectDir.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /rcpath:"$(WindowsSdkPath)\bin\x86\rc.exe"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /targetplatformsdklibpath:"$(_IlcTargetPlatformSdkLibPath)"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /targetplatformsdkmetadatapath:"$(_TargetPlatformMetadataPath)"</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /targetframeworkpath:"$(FrameworkPathOverride.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd Condition="'$(_IlcExternalReferencePath)' != '/externalReferencePath:&quot;&quot;'">$(_IlcCmd) $(_IlcExternalReferencePath)</_IlcCmd>
      <_IlcCmd Condition="'$(ProjectNVSTelemetrySession)' != ''"                                  >$(_IlcCmd) /VSTelemetrySessionSettings:$(ProjectNVSTelemetrySession)</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /RdXmlPath:"$(MSBuildThisFileDirectory)LibraryXML"</_IlcCmd>
      <_IlcCmd Condition="'$(_IlcSuppressPDBWarnings)'=='true'"                                   >$(_IlcCmd) /suppressPDBWarnings:$(_IlcSuppressPDBWarnings)</_IlcCmd>
      <_IlcCmd                                                                                    >$(_IlcCmd) /AllowNoManagedCode</_IlcCmd>
      <_IlcCmd Condition="'$(AppContextSwitches)' != ''"                                          >$(_IlcCmd) /AppContextSwitches:"$(AppContextSwitches)"</_IlcCmd>
      <_IlcCmd Condition="'$(SkipILCompilation)' == 'true'"                                       >$(_IlcCmd) /SkipILCompilation:$(SkipILCompilation)</_IlcCmd>
      <_IlcCmd Condition="'$(NetNativeReproPath)' != ''"                                          >$(_IlcCmd) /PackRepro:"$(NetNativeReproPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd Condition="'$(NetNativePdbPath)' != ''"                                            >$(_IlcCmd) /PdbPath:"$(NetNativePdbPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd Condition="'$(EnableNetNativeDeveloperExperienceMode)'!=''"                        >$(_IlcCmd) /developerExperience:$(EnableNetNativeDeveloperExperienceMode)</_IlcCmd>
      <_IlcCmd Condition="'$(UseNetNativeCustomFramework)' == 'true'"                             >$(_IlcCmd) /UseCustomFramework</_IlcCmd>

      <!-- The IlcParameters property allows for debug scenarios where overriding one of the built-in switches
           might be desirable. It should always come last, since ILC treats command line parameters at the end
           of its command line as having higher precedence -->
      <_IlcCmd Condition="'$(IlcParameters)' != ''">$(_IlcCmd) $(IlcParameters)</_IlcCmd>
      
      <_IlcResponseFile>$(IntermediateOutputPath.TrimEnd('\'))\ilc.$(MSBuildProjectName).rsp</_IlcResponseFile>
      <IlcCmd>"$(_IlcExePath)" @"$(_IlcResponseFile)"</IlcCmd>
    </PropertyGroup>

    <WriteLinesToFile File="$(_IlcResponseFile)" Lines="$(_IlcCmd)" Overwrite="true" />
    <ItemGroup>
      <FileWrites Include="$(_IlcResponseFile)"/>
    </ItemGroup>

    <LoggerBasedExecTask Command="$(IlcCmd)" MessageLog="$(_IlcIntermediateRootPath)ilclog.csv">
      <Output TaskParameter="ExitCode" PropertyName="_IlcExitCode" />
    </LoggerBasedExecTask>

    <!-- Preserve generated C# files in the ilc package output -->
    <ItemGroup>
      <_IlcGeneratedSource Include="$(_IlcIntermediatePath)**\*.g.cs" />
    </ItemGroup>
    <Copy SourceFiles="@(_IlcGeneratedSource)"
        DestinationFolder="$(_IlcOutputPath)"
        SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
        />

    <!-- Record intermediate and output files as file writes. -->
    <ItemGroup>
      <_IlcIntermediatePayload Include="$(_IlcIntermediatePath)**\*" />
      <_IlcOutputPayload Include="$(_IlcOutputPath)**\*" />
      <!-- Do not include manifest file in the payload -->
      <_IlcOutputPayload Remove="@(_IlcOutputPayload)" Condition="'%(Filename)%(Extension)' == '$(_AppxManifestXmlFileName)'"  />
      <FileWrites Include="@(_IlcIntermediatePayload)" />
      <FileWrites Include="@(_IlcOutputPayload)" />
    </ItemGroup>

    <!-- 
      Modify appx package payload so that the native package layout produced by ilc is used for deployment,
      and produce the payload for the appxupload so that Store can compile it. 
    -->
    <ItemGroup>
      <AppxUploadPackagePayload Include="@(AppxPackagePayload)" />
      <FinalAppxUploadManifest Remove="@(FinalAppxManifest)"/>
      <FinalAppxUploadManifest Include="$(_TransformedAppxManifestXmlFile)" />

      <AppxPackagePayload Remove="@(AppxPackagePayload)" />
      <AppxPackagePayload Include="@(_IlcOutputPayload)" Condition="'$(PlatformTarget)' != 'ARM' or '%(Extension)' != '.pdb'">
        <TargetPath>%(RecursiveDir)%(Filename)%(Extension)</TargetPath>
      </AppxPackagePayload>
      <AppxPackagePayload Remove="$(_IlcOutputPath)**\*.g.cs" />  
      <AppxPackagePayload Remove="$(_IlcOutputPath)**\*.xr.xml" />
    </ItemGroup>

    <PropertyGroup>
      <ProjectPriUploadFullPath>$(ProjectPriFullPath)</ProjectPriUploadFullPath>
    </PropertyGroup>

    <ItemGroup Condition="Exists('$(_TransformedAppxManifestXmlFile)')">
      <FinalAppxManifest Remove="@(FinalAppxManifest)"/>
      <FinalAppxManifest Include="$(_TransformedAppxManifestXmlFile)" />
    </ItemGroup>

    <!-- 
      AppxPackage targets depend on ProjectPriFullPath being correctly set. In particular for AppxBundles 
      the _CreatePackageLayout_CalculateInputsAndOutputs target expects this property to be set to exactly what
      is contained in the AppxPackagePayload because it removes it and if the path doesn't exactly match it fails.
    -->
    <PropertyGroup Condition="Exists('$(_TransformedProjectPriFullPath)')">
      <ProjectPriFullPath>$(_TransformedProjectPriFullPath)</ProjectPriFullPath>
    </PropertyGroup>

    <OnError ExecuteTargets="LogIlcBehavioralDifference"/>
  </Target>

  <Target Name="LogIlcBehavioralDifference">
    <PropertyGroup>
      <_IlcMinBehavioralExitCode>1400</_IlcMinBehavioralExitCode>
    </PropertyGroup>
    <IlcErrorTask Condition="'$(_IlcExitCode)' != '' and '$(_IlcExitCode)' &gt;= '$(_IlcMinBehavioralExitCode)'" ResourceName="Error_IlcBehavioralDifferences" />
  </Target>
</Project>